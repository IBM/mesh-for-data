apiVersion: v1
data:
  action_struct.rego: "package data_policies\n\n#general enforcment action structure\n\
    enforcement_action_struct = {\n    \"action_name\" : \"<name of action>\",\n \
    \   \"desription\" : \"<free text description of the action>\",\n    \"arguments\"\
    \ : \"<arguments set can be different for each action>\",\n    \"used_policy\"\
    \ : \"<used_policy_struct>\"\n}\n\nbuild_action_from_policies(used_policy) = action\
    \ {\n    action = {\n        \"used_policy\" : used_policy\n    }\n}\n\nbuild_action_from_name(action_name,\
    \ used_policy) = action {\n    action = {\n        \"action_name\" : action_name,\n\
    \        \"desription\" : action_name,\n        \"arguments\" :[],\n        \"\
    used_policy\" : used_policy\n    }\n}\n\nbuild_action(action_name, description,\
    \ arguments, used_policy) = action {\n    action = {\n        \"action_name\"\
    \ : action_name,\n        \"description\" : description,\n        \"arguments\"\
    \ :arguments,\n        \"used_policy\" : used_policy\n    }\n}\n\n###################################\
    \ Enforcement Actions #######################################\n\n#deny access\n\
    deny_access_struct = {\n    \"action_name\" : \"deny access\",\n    \"description\"\
    \ : \"Access to this data asset is denied\",\n    \"arguments\" : {},\n    \"\
    used_policy\" : \"<used_policy_struct>\"\n}\n\ndeny_write_struct = {\n    \"action_name\"\
    \ : \"deny\",\n    \"description\" : \"Writing of this data asset is denied\"\
    ,\n    \"arguments\" : {},\n    \"used_policy\" : \"<used_policy_struct>\"\n}\n\
    \nbuild_deny_access_action(used_policies) = action {\n    action = build_action(deny_access_struct.action_name,\
    \ deny_access_struct.description, deny_access_struct.arguments, used_policies)\n\
    }\n\nbuild_deny_write_action(used_policies) = action {\n    action = build_action(deny_write_struct.action_name,\
    \ deny_write_struct.description, deny_write_struct.arguments, used_policies)\n\
    }\n\n#remove column\nremove_column_struct = {\n    \"action_name\" : \"remove\
    \ column\",\n    \"description\" : \"Single column is removed\",\n    \"arguments\"\
    \ : { \n        \"column_name\": \"<column name>\"\n    },\n    \"used_policy\"\
    \ : \"<used_policy_struct>\"\n}\n\nbuild_remove_column_action(column_name, used_policies)\
    \ = action {\n    args := { \n       \"column_name\" : column_name\n    }\n  \
    \  action = build_action(remove_column_struct.action_name, remove_column_struct.description,\
    \ args, used_policies)\n}\n\n#encrypt colmn\nencrypt_column_struct = {\n    \"\
    action_name\" : \"encrypt column\",\n    \"description\" : \"Single column is\
    \ encrypted with its own key\",\n    \"arguments\" : { \n        \"column_name\"\
    : \"<column name>\"\n    },\n    \"used_policy\" : \"<used_policy_struct>\"\n\
    }\n\nbuild_encrypt_column_action(column_name, used_policies) = action {\n    args\
    \ := { \n       \"column_name\" : column_name\n    }\n    action = build_action(encrypt_column_struct.action_name,\
    \ encrypt_column_struct.description, args, used_policies)\n}\n\n#mask_redact_column\n\
    redact_column_struct = {\n    \"action_name\" : \"redact column\",\n    \"description\"\
    \ : \"Single column is obfuscated with XXX instead of values\",\n    \"arguments\"\
    \ : { \n        \"column_name\": \"<column name>\"\n    },\n    \"used_policy\"\
    \ : \"<used_policy_struct>\"\n}\n\nbuild_redact_column_action(column_name, used_policies)\
    \ = action {\n    args := { \n       \"column_name\" : column_name\n    }\n  \
    \  action = build_action(redact_column_struct.action_name, redact_column_struct.description,\
    \ args, used_policies)\n}\n\n#periodic_blackout\nperiodic_blackout_struct = {\n\
    \    \"action_name\" : \"periodic blackout\",\n    \"description\" : \"Access\
    \ to dataset is denied based on date of the access\",\n    \"arguments\" : { \n\
    \        #only one of the arguments should be filled in\n        \"monthly_days_end\"\
    : \"<number of days before the end of month when data is denied>\",\n        \"\
    yearly_days_end\": \"<number of days before the end of year when data is denied>\"\
    ,\n    },\n    \"used_policy\" : \"<used_policy_struct>\"\n}\n\nbuild_monthly_periodic_blackout_action(days_before_month_end,\
    \ used_policies) = action {\n    args := { \n       \"monthly_days_end\" : days_before_month_end\n\
    \    }\n    action = build_action(periodic_blackout_struct.action_name, periodic_blackout_struct.description,\
    \ args, used_policies)\n}\n\nbuild_yearly_periodic_blackout_action(days_before_year_end,\
    \ used_policies) = action {\n    args := { \n       \"yearly_days_end\" : days_before_year_end\n\
    \    }\n    action = build_action(periodic_blackout_struct.action_name, periodic_blackout_struct.description,\
    \ args, used_policies)\n}"
  auditing_struct.rego: "package data_policies\n\n#general structure ofused policy\
    \ for auditing\nused_policy_struct = {\n    \"policy_id\" : \"<unique id>\",\n\
    \    \"description\" : \"<free text description of the policy reason>\",\n   \
    \ \"policy_type\" : \"<classification of policy itslef>\",\n    \"hierarchy\"\
    \ : \"<relation to other policies>\"\n}\n\nbuild_policy_from_id(id) = policy {\n\
    \    policy = { \"policy_id\" : id }\n}\n\nbuild_policy_from_description(desc)\
    \ = policy {\n    policy = { \"description\" : desc }\n}\n\nbuild_policy(id, desc,\
    \ type, hierarchy) = policy {\n    policy = {\n        \"policy_id\" : id,\n \
    \       \"description\" : desc,\n        \"policy_type\" : type,\n        \"hierarchy\"\
    \ : hierarchy\n    }\n}"
  helper_functions.rego: "package data_policies\n\n#general functions that make data-policies\
    \ composing easier\n\nverify_access_type {\n\t\tcompare_str(AccessType(), AccessTypes[_])\n\
    }\n\nverify_purpose {\n\t\tcompare_str(Purpose(), Purposes[_])\n}\n\nverify_role\
    \ {\n\tcompare_str(Role(), Roles[_])\n}\n\nverify_geography {\n    compare_str(ProcessingGeo(),\
    \ GeoDestinations[_])\n}\n\ndataset_has_tag(tag) {\n    compare_str(tag,  DatasetTags()[_])\n\
    }\n\ndataset_has_tag_not(tag) {\n    compare_str_not(tag,  DatasetTags()[_])\n\
    }\n\ncheck_access_type(access_types) {\n    compare_str(AccessType(), access_types[_])\n\
    }\n\ncheck_destination(destinations) {\n    compare_str(DestinationGeo(), destinations[_])\n\
    }\n\ncheck_processingGeo_not(processingGeo) {\n\tcompare_str_not(processingGeo,\
    \ ProcessingGeo())\n}\n\nclean_string(str) = result {\n    str2 := lower(str)\n\
    \    str3 = replace(str2, \" \", \"\")\n    str4 := replace(str3, \"-\", \"\"\
    )\n    str5 := replace(str4, \"_\", \"\")\n\n    result=str5\n}\n\ncompare_str(str1,\
    \ str2) {\n    clean_string(str1) == clean_string(str2)\n}\n\n\ncolumn_has_tag(tag)\
    \ {\n\tcompare_str(tag, input.details.metadata.components_metadata[_].tags[_])\n\
    }\n\ncheck_purpose(purpose) {\n    compare_str(purpose, Purpose())\n}\n\ncheck_role(role)\
    \ {\n    compare_str(role, Role())\n}\n\ncheck_role_not(role) {\n    compare_str_not(role,\
    \ Role())\n}\n\ncheck_processingGeo_not(processingGeo) {\n\tcompare_str_not(processingGeo,\
    \ ProcessingGeo())\n}\n\ncompare_str_not(str1, str2) {\n    clean_string(str1)\
    \ != clean_string(str2)\n}"
  input_reader.rego: "package data_policies\n\n#this file assumes input to be provided\
    \ in specific format, in this case how data mesh provides it \n#similar file can\
    \ be built for Egeria, at least for the metadata part, or any other catalog when\
    \ we show how the input should be  parsed correctly\n\n#Example structure:\n#\
    \ {\n# \t\"name\": \"<name>\"\n# \t\"destination\": \"<destination>\",\n# \t\"\
    processing_geography\": \"<processing_geography>\",\n# \t\"purpose\": \"<purpose>\"\
    ,\n# \t\"role\": \"<role>\",\n# \t\"type\": \"<access type>\",\n# \t\"details\"\
    : {\n# \t\t\"data_format\": \"<data_format>\",\n# \t\t\"data_store\": {\n# \t\t\
    \t\"name\": \"<datastore name>\"\n# \t\t},\n# \t\t\"geo\": \"<geo>\",\n# \t\t\"\
    metadata\": {\n# \t\t\t\"components_metadata\": {\n# \t\t\t\t\"<column name1>\"\
    : {\n# \t\t\t\t\t\"component_type\": \"column\",\n# \t\t\t\t\t\"named_metadata\"\
    : {\n# \t\t\t\t\t\t\"type\": \"length=10.0,nullable=true,type=date,scale=0.0,signed=false\"\
    \n# \t\t\t\t\t}\n# \t\t\t\t},\n# \t\t\t\t\"<column name2>\": {\n# \t\t\t\t\t\"\
    component_type\": \"column\",\n# \t\t\t\t\t\"named_metadata\": {\n# \t\t\t\t\t\
    \t\"type\": \"length=3.0,nullable=true,type=char,scale=0.0,signed=false\"\n# \t\
    \t\t\t\t},\n# \t\t\t\t\t\"tags\": [\"<tag1>\", \"<tag2>\"]\n# \t\t\t\t}\n# \t\t\
    \t},\n# \t\t\t\"dataset_named_metadata\": {\n# \t\t\t\t\"<term1 name>\": \"<term1\
    \ value>\",\n# \t\t\t\t\"<term2 name>\": \"<term2 value>\"\n# \t\t\t},\n# \t\t\
    \t\"dataset_tags\": [\n# \t\t\t\t\"<tag1>\",\n# \t\t\t\t\"<tag2>\"\n# \t\t\t]\n\
    # \t\t},\n# \t}\n# }\nProperties() = input.properties\n\nPurpose() = Properties().intent\
    \ \n\nRole() = Properties().role\n\nAccessType() = input.type \n\nDatasetTags()\
    \ = input.details.metadata.dataset_tags\n\nProcessingGeo() = input.processing_geography\n\
    \nDestinationGeo() = input.destination\n\n\n\ncolumn_with_tag(tag) = column_names\
    \ {\n\tcolumn_names := [column_name | input.details.metadata.components_metadata[column_name].tags[_]\
    \ == tag]\n}\n\ncolumn_with_any_tag(tags) = column_names {\n\tcolumn_names :=\
    \ [column_name | input.details.metadata.components_metadata[column_name].tags[_]\
    \ == tags[_]]\n}\n\ncolumn_with_any_name(names) = column_names {\n\tall_column_names\
    \ := {column_name | input.details.metadata.components_metadata[column_name] }\n\
    \    column_names := all_column_names & names\n}"
  taxonomies_unification.rego: 'package data_policies


    #In data part we provide set of general and industry specific taxonomies, also
    the user can add more taxonomies specific for his needs.

    #Here is the place when for each category user chooses what taxonomies should
    be used


    Purposes = { x | x = data["m4d-system"]["meshfordata-external-data"]["taxonomies.json"].DataPurposes[_]
    }


    Roles = { x | x = data["m4d-system"]["meshfordata-external-data"]["taxonomies.json"].DataRoles[_]
    } | { x | x = data["m4d-system"]["meshfordata-external-data"]["medical_taxonomies.json"].MedicalRoles[_]
    }


    Sensitivity = { x | x = data["m4d-system"]["meshfordata-external-data"]["taxonomies.json"].DataSensitivity[_]
    }


    AccessTypes = { x | x = data["m4d-system"]["meshfordata-external-data"]["taxonomies.json"].DataAccessTypes[_]
    }


    GeoDestinations = { x | x = data["m4d-system"]["meshfordata-external-data"]["taxonomies.json"].DataGeoDestinations[_]
    }'
  verify_correct_input.rego: "package data_policies\n\ncorrect_input {\n\tcount(incorrect_input)\
    \ == 0\n}\n\nincorrect_input[used_policy] {\n   not verify_access_type\n   used_policy\
    \ := build_action_from_policies(build_policy_from_description(\"unknown access\
    \ type\"))\n} {\n    not verify_purpose\n    used_policy := build_action_from_policies(build_policy_from_description(\"\
    unknown purpose\"))\n} {\n    not verify_role\n    used_policy := build_action_from_policies(build_policy_from_description(\"\
    unknown role\"))\n} {\n\tcheck_access_type([\"COPY\"])\n    not verify_geography\n\
    \    used_policy := build_action_from_policies(build_policy_from_description(\"\
    unknown geography to copy the data\"))\n}"
kind: ConfigMap
metadata:
  labels:
    openpolicyagent.org/policy: rego
  name: opa-m4d-policy-lib
