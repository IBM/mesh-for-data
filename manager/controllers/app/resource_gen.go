// Copyright 2020 IBM Corp.
// SPDX-License-Identifier: Apache-2.0

package app

import (
	"context"

	"emperror.dev/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"

	app "github.com/ibm/the-mesh-for-data/manager/apis/app/v1alpha1"
	corev1 "k8s.io/api/core/v1"
)

// ResourceStatus represents a part of the generated resource status that allows update of M4DApplication status
type ResourceStatus struct {
	// Ready represents that the modules have been orchestrated successfully and the data is ready for usage
	Ready bool
	// Error indicates that there has been an error to orchestrate the modules and provides the error message
	Error string
	// DataAccessInstructions indicate how the data user or his application may access the data.
	// Instructions are available upon successful orchestration.
	DataAccessInstructions string
}

// ContextInterface is an interface for communication with a generated resource (e.g. Blueprint)
type ContextInterface interface {
	ResourceExists(metadata *app.ResourceMetadata) bool
	CreateOrUpdateResource(metadata *app.ResourceMetadata, blueprintPerClusterMap map[string]app.BlueprintSpec) error
	DeleteResource(metadata *app.ResourceMetadata) error
	GetResourceStatus(metadata *app.ResourceMetadata) (ResourceStatus, error)
	CreateResourceMetadata(appName string, appNamespace string) (*app.ResourceMetadata, error)
	GetManagedObject() runtime.Object
}

// Interface for managing Blueprint resources

// BlueprintInterface context implementation for communication with a single Blueprint resource
type BlueprintInterface struct {
	Client client.Client
}

// GetManagedObject returns the type of the managed runtime object
func (c *BlueprintInterface) GetManagedObject() runtime.Object {
	return &app.Blueprint{}
}

// CreateResourceMetadata returns metadata (name and namespace) of the generated resource.
// It also creates a namespace where the blueprint and the orchestrated resources will be running
func (c *BlueprintInterface) CreateResourceMetadata(appName string, appNamespace string) (*app.ResourceMetadata, error) {
	genNamespace := &corev1.Namespace{ObjectMeta: metav1.ObjectMeta{GenerateName: "m4d-"}}
	genNamespace.Labels = map[string]string{
		"m4d.ibm.com.owner": appNamespace + "." + appName,
	}
	if err := c.Client.Create(context.Background(), genNamespace); err != nil {
		return nil, err
	}
	return &app.ResourceMetadata{Name: appName, Namespace: genNamespace.Name, Kind: "Blueprint"}, nil
}

// ResourceExists checks whether the blueprint resource generated by M4DApplication controller is active
func (c *BlueprintInterface) ResourceExists(metadata *app.ResourceMetadata) bool {
	if metadata == nil || metadata.Namespace == "" {
		return false
	}
	resource := c.GetResourceSignature(metadata)
	if err := c.Client.Get(context.Background(), types.NamespacedName{Namespace: metadata.Namespace, Name: metadata.Name}, resource); err != nil {
		return false
	}
	return true
}

// GetResourceSignature returns the namespaced metadata of the generated Blueprint resource
func (c *BlueprintInterface) GetResourceSignature(metadata *app.ResourceMetadata) *app.Blueprint {
	return &app.Blueprint{
		ObjectMeta: metav1.ObjectMeta{
			Name:      metadata.Name,
			Namespace: metadata.Namespace,
		},
	}
}

// CreateOrUpdateResource creates a new Blueprint resource or updates an existing one
func (c *BlueprintInterface) CreateOrUpdateResource(metadata *app.ResourceMetadata, blueprintPerClusterMap map[string]app.BlueprintSpec) error {
	resource := c.GetResourceSignature(metadata)
	if len(blueprintPerClusterMap) != 1 {
		return errors.New("Invalid cluster configuration")
	}
	// There is no actual iteration loop, since the map includes a single BlueprintSpec element
	for _, blueprintSpec := range blueprintPerClusterMap {
		if _, err := ctrl.CreateOrUpdate(context.Background(), c.Client, resource, func() error {
			resource.Spec = blueprintSpec
			return nil
		}); err != nil {
			return err
		}
	}
	return nil
}

// DeleteResource deletes the generated Blueprint resource
func (c *BlueprintInterface) DeleteResource(metadata *app.ResourceMetadata) error {
	resource := c.GetResourceSignature(metadata)
	if err := c.Client.Delete(context.Background(), resource); err != nil {
		return err
	}
	return c.Client.Delete(context.Background(), &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: metadata.Namespace,
		}})
}

// GetResourceStatus returns the generated Blueprint status
func (c *BlueprintInterface) GetResourceStatus(metadata *app.ResourceMetadata) (ResourceStatus, error) {
	if metadata == nil || metadata.Namespace == "" {
		return ResourceStatus{}, nil
	}
	resource := c.GetResourceSignature(metadata)
	if err := c.Client.Get(context.Background(), types.NamespacedName{Namespace: metadata.Namespace, Name: metadata.Name}, resource); err != nil {
		return ResourceStatus{}, err
	}
	return ResourceStatus{DataAccessInstructions: resource.Status.DataAccessInstructions,
		Ready: resource.Status.Ready,
		Error: resource.Status.Error,
	}, nil
}

// NewBlueprintInterface creates a new blueprint interface for M4DApplication controller
func NewBlueprintInterface(cl client.Client) *BlueprintInterface {
	return &BlueprintInterface{
		Client: cl,
	}
}

// Interface for managing Plotter resources

// PlotterInterface context implementation for communication with a single Plotter resource
type PlotterInterface struct {
	Client client.Client
}

// GetManagedObject returns the type of the managed runtime object
func (c *PlotterInterface) GetManagedObject() runtime.Object {
	return &app.Plotter{}
}

// CreateResourceMetadata returns metadata (name and namespace) of the generated resource.
func (c *PlotterInterface) CreateResourceMetadata(appName string, appNamespace string) (*app.ResourceMetadata, error) {
	// Plotter runs in the same namespace. Plotter name identifies m4dapplication (name and namespace)
	return &app.ResourceMetadata{Name: appName + "-" + appNamespace, Namespace: appNamespace, Kind: "Plotter"}, nil
}

// ResourceExists checks whether the Plotter resource generated by M4DApplication controller is active
func (c *PlotterInterface) ResourceExists(metadata *app.ResourceMetadata) bool {
	if metadata == nil || metadata.Namespace == "" {
		return false
	}
	resource := c.GetResourceSignature(metadata)
	if err := c.Client.Get(context.Background(), types.NamespacedName{Namespace: metadata.Namespace, Name: metadata.Name}, resource); err != nil {
		return false
	}
	return true
}

// GetResourceSignature returns the namespaced metadata of the generated Plotter resource
func (c *PlotterInterface) GetResourceSignature(metadata *app.ResourceMetadata) *app.Plotter {
	return &app.Plotter{
		ObjectMeta: metav1.ObjectMeta{
			Name:      metadata.Name,
			Namespace: metadata.Namespace,
		},
	}
}

// CreateOrUpdateResource creates a new Plotter resource or updates an existing one
func (c *PlotterInterface) CreateOrUpdateResource(metadata *app.ResourceMetadata, blueprintPerClusterMap map[string]app.BlueprintSpec) error {
	resource := c.GetResourceSignature(metadata)
	if len(blueprintPerClusterMap) == 0 {
		return errors.New("Invalid cluster configuration")
	}
	if _, err := ctrl.CreateOrUpdate(context.Background(), c.Client, resource, func() error {
		resource.Spec.Blueprints = blueprintPerClusterMap
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// DeleteResource deletes the generated Plotter resource
func (c *PlotterInterface) DeleteResource(metadata *app.ResourceMetadata) error {
	resource := c.GetResourceSignature(metadata)
	if err := c.Client.Delete(context.Background(), resource); err != nil {
		return err
	}
	return nil
}

// GetResourceStatus returns the generated Plotter status
func (c *PlotterInterface) GetResourceStatus(metadata *app.ResourceMetadata) (ResourceStatus, error) {
	if metadata == nil || metadata.Namespace == "" {
		return ResourceStatus{}, nil
	}
	resource := c.GetResourceSignature(metadata)
	if err := c.Client.Get(context.Background(), types.NamespacedName{Namespace: metadata.Namespace, Name: metadata.Name}, resource); err != nil {
		return ResourceStatus{}, err
	}
	return ResourceStatus{DataAccessInstructions: resource.Status.DataAccessInstructions,
		Ready: resource.Status.Ready,
		Error: resource.Status.Error,
	}, nil
}

// NewPlotterInterface creates a new plotter interface for M4DApplication controller
func NewPlotterInterface(cl client.Client) *PlotterInterface {
	return &PlotterInterface{
		Client: cl,
	}
}
